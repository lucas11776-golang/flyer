// Cargo.toml (add)
// [dependencies]
// tokio = { version = "1", features = ["full"] }

use std::future::Future;
use std::pin::Pin;
use std::sync::Arc;

// -------------------------------
// Dummy Request & Response types
// -------------------------------
#[derive(Default, Debug)]
pub struct Request {
    pub body: String,
}

#[derive(Default, Debug)]
pub struct Response {
    pub body: String,
}

// Convenience alias for boxed pinned futures with the right lifetime handling
type WebResponse<'a> = Pin<Box<dyn Future<Output = &'a mut Response> + Send + 'a>>;

// -------------------------------
// RouteHandler trait: dynamic object
// -------------------------------
pub trait WebRouteHandler: Send + Sync {
    fn call<'a>(&'a self, req: &'a mut Request, res: &'a mut Response) -> WebResponse<'a>;
}

// -----------------------------------------------------
// Implement RouteHandler for any handler function/closure
// that itself returns a WebResponse<'a> for any 'a.
// This requires the handler to already return a boxed future.
// -----------------------------------------------------
impl<T> WebRouteHandler for T
where
    // The handler must be callable for any lifetime 'a and produce WebResponse<'a>
    T: for<'a> Fn(&'a mut Request, &'a mut Response) -> WebResponse<'a> + Send + Sync + 'static,
{
    fn call<'a>(&'a self, req: &'a mut Request, res: &'a mut Response) -> WebResponse<'a> {
        (self)(req, res)
    }
}

// -------------------------------
// Route and Router definitions
// -------------------------------
pub struct Route<T> {
    pub path: String,
    pub method: String,
    pub handler: Arc<T>,
}

pub struct Router {
    pub routes: Vec<Route<Box<dyn WebRouteHandler>>>,
}

impl Router {
    pub fn new() -> Self {
        Self { routes: vec![] }
    }

    /// Adds a handler that must return a boxed future (WebResponse<'a>)
    pub fn add_web_route<H>(&mut self, method: &str, path: &str, handler: H)
    where
        H: for<'a> Fn(&'a mut Request, &'a mut Response) -> WebResponse<'a> + Send + Sync + 'static,
    {
        self.routes.push(Route {
            path: path.to_string(),
            method: method.to_string(),
            handler: Arc::new(Box::new(handler)),
        });
    }

    /// Find route by path (very simple) and call it
    pub async fn handle<'a>(&'a self, path: &str, req: &'a mut Request, res: &'a mut Response) -> &'a mut Response {
        let route = self.routes.iter().find(|r| r.path == path).unwrap();
        // call returns WebResponse<'a>
        let fut = route.handler.call(req, res);
        
        return fut.await;
        // Some(out)
    }
}

// -------------------------------
// Example usage
// -------------------------------
#[tokio::main]
async fn main() {
    let mut router = Router::new();

    // Register a handler: NOTE we box the future inside the closure
    router.add_web_route("GET", "/hello", |req: &mut Request, res: &mut Response| {
        // Box the future so types match WebResponse<'a>
        Box::pin(async move {
            // mutate response and return it by mutable borrow
            res.body = format!("Hello, {}", req.body);
            res
        })
    });

    // Simulate request
    let mut req = Request {
        body: "World".into(),
    };
    let mut res = Response::default();

    let resp = router.handle("/hello", &mut req, &mut res).await;


    println!("Response body: {}", resp.body);
}
